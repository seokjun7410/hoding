# 9장 


### 쿼리 실행 절차
- 요청된 sql 문장을 잘개 쪼개서 분리한다.
- `[SQL Paser -> 파스트리 산출]`
- SQL 파싱정보(파스트리)를 확인하여 어떤테이블을 읽고 어떤 INDEX를 이용할지 선택한다. 
- `[Mysql 옵티마이저 -> 실행계획 산출]`
  - 불필요한 조건제거, 연산 단순화
  - 조인이 있는 경우 테이블 읽는 순서 결졍
  - 상황을 고려하여 인덱스 통게정보를 이용해 인덱스를 결정
  - 가져온 레코드들을 임시테이블에 넣고 더 가공이 필요한진 판단
- 두번째 단계에서 결정된 테이블의 읽기순서나 선택된 인덱스를 사용하 Mysql스토리지 엔진으로부터 데이터를 가져온다.
  - Mysql엔진과 동시에 참여한다.
  - MYsql엔진에서 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다.

```
SQL Paser가 요청된 SQL을 잘개 쪼개어 파스트리를 생성하고 옵티마이저가 최적화여 실행계획을 산출한 뒤
  실행계획을 바탕으로스토리지 엔진으로부터 레코드를 가져와서 조인하거나 정렬하는 작업을 수행한다.
```

### 옵티마이저 종류
- 옵티마이저는 Mysql의 두뇌역할을 한다.

### 비용기반 최적화
- 여러 방법을 구상하고 각 단위 작업의 비용정보와 대상 테이블의 예측된 통계정보를 이용해 실행 계획별 비용중 최소를 선택한다.
- 통계정보를 이용해 최적화 한단느 것. Mysql에서 채택하고 있는 방식이다.
### 규칙기반 최적화
- 내부의 설정된 우선순위를 기반으로 실행계획을 세운다.
  - 특징으로는 거의 항상 같은 실행계획이 산출된다. 안쓴다.


### Mysql 알고리즘
` - 풀테이블 스캔 : Index를 사용하지 않는다. `
#### 조건
- 테이블에 존재하는 레코드 건수가 적을경우
  - 인댁스를 사용하는 것보다 다 읽는게 더빠를때가 있다.
- 좌측 접두사가 없을경우
- 통계정보 기반 range가 넓은 경우
```java
지난 단원 참고
        100만개중 50만개 읽기
        풀 테이블 스캔 VS INDEX
        전체행의 20~25프로를 넘게 읽으면 손익분기점을 넘긴다.
        옵티마이저가 자동으로 인덱스 사용을 반려시킨다.
```
#### 특징
- 특정테이블의 연속된 데이터 페이지를 읽을 때 InnoDb 버퍼풀에 캐싱한다.

` - 풀 인덱스 스캔 : 인덱스를 처음부터 끝까지 스캔 `
```sql
    SELECT COUNT(*) FROM employees;   
```

#### 병렬처리
- WHERE 조건 없이 전체건수(= "Count(*)") 가져오는 쿼리만 병렬로 처리할 수 있다.

### OrderBy 처리
- 대부분의 Select 쿼리에서 정렬은 필수적으로 사용된다.
### 정렬처리 방법
- `INDEX 이용`
- 장점 : 인덱스는 이미 정렬되어 있기 때문에 순서대로 읽기만 하면 된다.
- 단점 : INSERT, DELETE, UPDATE가 느리다. 인덱스로 인한 디스크용량이슈, 버퍼풀 용량이슈가 고려되어야한다.
- `Filesort 이용`
- 장점 : 레코드가 많지 않으면 메모리에서 처리되므로 빠르다.
- 단점 : 정렬이 쿼리 실행시 처리되므로 레코드 대상 건수가 많아질수록 느려진다.

### INDEX로 정렬할 수 없는 경우
- 정렬기준이 너무 많은 경우
- GroupBy, Distinct 같은 처리의 결과를 정렬해야하는 경우
- Union처럼 임시테이블의 결과를 다시 정렬해야하는 경우
- 랜덤하게 결과 레코드를 가져와야 하는 경우

### 인덱스를 이용하지 않고 정렬처리 수행했는지 판단하는 법
- 실행계획 Extra 컬럼에 Using Filesort를 확인하면 된다.


### 소트버퍼
`정렬을 수행하기 위해 할당받는 별도의 메모리 공간`
- 가변적 증가
- 정렬이 필요한 경우만 할당
- 시스템 변수로 공간 설정 가능
- 쿼리 실행 완료되면 즉시 반납
```
정렬이 문제될 떄
  - 정렬할 레코드가 소트버퍼보다 클 경우
  - 여러 조각으로 나누어 처리
  - 이때 임시 저장을 위해 디스크 사용 `disk I/O 발생`
  - 멀티머지 후 종료
  ```
- 소트버퍼 크기에 비례해서 빨라지지 않는다.
  - 서버 전체메모리를 많이 침범하게 될 수록 성능저하가 발생한다..
  - 저자는 56kb~1MB를 추천한다.
- 세션 메모리 영역이다.
- 여러 클라이언트가 공유할 수 없다.
- 커넥션이 많아질 경우 메모리 사용이 커진다.
#### 소트버퍼를 크게 설정할만한 상황
- 디스크 성능이 낮을경우 디스크 I/O를 줄이기 위한 용도
- 대용량 정렬 필요시 일시적으로 늘려서 사용

### 정렬 알고리즘
- 정렬할 때 소트버퍼에 전체를 담을지(싱글패스), 정렬기준 칼럼만 담을지(투패스)에 따라 나뉜다.
- 옵티마이저 트레이스 기능으로 확인할 수 없다.

```sql
에시 SQL
SELECT emp_no, first_name, last_name
FROM emplyees
ORDER BY first_name
```
#### 싱글패스 정렬방식
- 스토리지 엔진으로 부터 필요한 레코드를 모두 조회한 후 정렬하여 반환한다.
- 필요한 필드를 모두 조회해서 정렬한다.
#### 투패스 정렬방식
- PK와 정렬에 필요한 레코드만 가져와서 정렬을 수행한다.
- 정렬후에 PK로 다시 필요한 데이터를 조회한다.
```sql
SELECT 대상에 BLOB이나 TEXT타입의 크기가 큰 컬럼이 포함될 때 유용하다.
```
- 일반적으로 싱글패스 정렬 방식을 주로 사용한다.

### 정렬 처리 방법
`쿼리에 order By가 사용될 때 처리되는 방법`
- 인덱스를 사용한 정렬 -> 이미 정렬되어있다.
- 조인에서 드라이빙 테이블만 정렬 -> using filesort
- 조인결과를 임시 테이블로 저장 후 정렬 using temporary; using filesort
- 

